# Парадигмы программирования

Парадигмы программирования — это подходы к организации и структуре кода, которые определяют, как разработчики решают задачи и строят программы.

1. Императивное программирование:

   • Описание шагов, которые должен выполнить компьютер для достижения цели.

   • Программы состоят из последовательности команд.

   • Языки: C, Python, Java.

2. Декларативное программирование:

   • Описание того, что должно быть сделано, а не как это сделать.

   • Программист задает условия, а система сама определяет, как их выполнить.

   • Языки: SQL, HTML.

3. Объектно-ориентированное программирование (ООП):

   • Основной концепцией являются объекты, которые содержат данные и методы.

   • Поддерживает наследование, инкапсуляцию и полиморфизм.

   • Языки: Java, C++, Python.

4. Функциональное программирование:

   • Основано на математических функциях и избегает изменения состояния и данных.

   • Поддерживает функции как высшие объекты (можно передавать как аргументы и возвращать).

   • Языки: Haskell, Scala, Erlang.

5. Логическое программирование:

   • Основывается на формальной логике.

   • Программы описываются в виде фактов и правил, а выполнение осуществляется через вывод.

   • Языки: Prolog.

6. Событийно-ориентированное программирование:

   • Программы реагируют на события (например, пользовательские действия).

   • Широко используется в разработке графических интерфейсов и веб-приложений.

   • Языки: JavaScript, ActionScript.

7. Параллельное и распределенное программирование:

   • Фокусируется на выполнении нескольких вычислений одновременно.

   • Применяется в многопоточных приложениях и распределенных системах.

   • Языки: Go, Erlang.

## JavaScript и ООП.

JavaScript поддерживает классы, и в последние годы его возможности в области объектно-ориентированного программирования (ООП) значительно расширились. Однако важно понимать, что JavaScript изначально был языком, основанным на прототипах, а не на классах. Вот несколько ключевых моментов, которые помогут прояснить ситуацию:

1. Прототипное наследование: 

   • В JavaScript объекты могут наследовать свойства и методы от других объектов через прототипы. Это отличается от классического ООП, где наследование происходит через классы.

   • Каждый объект в JavaScript имеет свойство [[Prototype]], которое указывает на другой объект. Это позволяет создавать цепочки прототипов.

2. Классы в ES6:

   • В ECMAScript 2015 (ES6) были введены синтаксические конструкции для классов, что сделало код более понятным и похожим на традиционные языки ООП, такие как Java или C#.

   • Однако даже с введением классов, под капотом JavaScript все еще использует прототипное наследование.

3. Объектно-ориентированное программирование:

   • JavaScript поддерживает многие концепции ООП, такие как инкапсуляция, наследование и полиморфизм. Вы можете создавать объекты, определять методы и использовать классы.

   • Тем не менее, из-за своей прототипной природы он может вести себя иначе, чем языки с классическим ООП.

4. Смешанная парадигма:

   • JavaScript является мультипарадигменным языком, что означает, что он поддерживает как объектно-ориентированный, так и функциональный подходи (например, функции как объекты первого класса).

   • Вы можете использовать JavaScript как для ООП, так и для функционального программирования в зависимости от ваших предпочтений и требований проекта.

Таким образом, JavaScript может быть охарактеризован как объектно-ориентированный язык с прототипным наследованием. Он позволяет использовать классы и ООП-подходы, но его основная модель наследования отличается от традиционных языков ООП.

## Что такое проттотипирование?

JavaScript был создан в 1995 году Брэндоном Айком в компании Netscape. Изначально язык разрабатывался как простой скриптовый язык для браузеров, и его концепции были вдохновлены другими языками, такими как Scheme и Self. Вот краткая история развития прототипного наследования в JavaScript:

1. Ранние версии JavaScript

    Когда JavaScript только появился, он не имел концепции классов, как это было в других языках программирования, таких как Java или C++. Вместо этого он использовал объекты и функции как основные строительные блоки. В JavaScript функции могут быть созданы как объекты первого класса, что означает, что они могут быть переданы как аргументы, возвращены из других функций и т. д.

2. Прототипное наследование

    Вместо классов JavaScript использует прототипное наследование. Каждый объект может иметь свой прототип — другой объект, от которого он наследует свойства и методы. Это означает, что вы можете создавать новые объекты на основе существующих, добавляя или переопределяя свойства и методы.

3. Введение в функции-конструкторы

    С появлением функций-конструкторов (впервые в JavaScript 1.1) разработчики начали использовать их для создания объектов с общими свойствами и методами. Например:

```javascript
function Person(name) {
    this.name = name;
}

Person.prototype.greet = function() {
    console.log(Привет, меня зовут ${this.name}.);
};

const alice = new Person('Алиса');
alice.greet();
```
    
    Это стало основой для создания объектов и их наследования через прототипы.

4. ES5 и Object.create

    С выходом ECMAScript 5 (ES5) в 2009 году появилась возможность более явно управлять прототипами через метод Object.create(). Этот метод позволяет создавать новый объект с указанным прототипом, что сделало создание объектов с наследованием более интуитивно понятным.

5. ES6 и классы

    В 2015 году с выходом ECMAScript 6 (ES6) в JavaScript были введены синтаксические конструкции для классов, которые скрывают детали прототипного наследования и делают код более читаемым для разработчиков, привыкших к классическим языкам. Однако под капотом все равно используется прототипное наследование:

```javascript
class Person {
    constructor(name) {
        this.name = name;
    }
    
    greet() {
        console.log(Привет, меня зовут ${this.name}.);
    }
}

const alice = new Person('Алиса');
alice.greet(); // Привет, меня зовут Алиса.
```

Прототипное наследование в JavaScript изначально возникло как альтернатива классической объектно-ориентированной модели. С течением времени язык развивался, и появились новые синтаксические конструкции, но основа — прототипы — осталась неизменной. Это сделало JavaScript уникальным языком с гибкой системой наследования, позволяющей разработчикам создавать сложные структуры и делиться функциональностью между объектами без необходимости использовать классы.

## Немного о классическом ООП.

Рассмотрим это на примере PHP, его нам предстоит изучать в будущем.

Объектно-ориентированное программирование (ООП) — это парадигма программирования, основанная на концепции "объектов", которые могут содержать как данные, так и код. ООП позволяет организовать код таким образом, чтобы он был более понятным, гибким и легко поддерживаемым. Основные концепции ООП включают в себя:

1. Классы и объекты

• Класс — это шаблон или чертеж для создания объектов. Он определяет свойства (данные) и методы (функции), которые будут доступны объектам.

• Объект — это экземпляр класса. Он содержит конкретные данные и может выполнять методы, определенные в классе.

Пример: Представьте класс Автомобиль. Он может иметь свойства, такие как цвет, модель и методы, такие как завести() и остановить(). Объектом этого класса будет конкретный автомобиль, например, красная Toyota.

2. Инкапсуляция

Инкапсуляция — это механизм ограничения доступа к внутренним данным объекта и предоставления интерфейса для взаимодействия с этими данными. Это достигается с помощью модификаторов доступа (public, protected, private).

Пример: В классе Банк можно сделать свойство баланс приватным, чтобы его нельзя было изменить напрямую извне. Вместо этого можно создать методы внести() и снять(), которые будут управлять изменением баланса.

```php
class BankAccount {
    private $balance;

    public function __construct($initialBalance) {
        $this->balance = $initialBalance;
    }

    public function deposit($amount) {
        if ($amount > 0) {
            $this->balance += $amount;
        }
    }

    public function getBalance() {
        return $this->balance;
    }
}
```

3. Наследование

Наследование позволяет создавать новый класс на основе существующего, унаследовав его свойства и методы. Это помогает избежать дублирования кода.

Пример: Если у вас есть класс Животное, вы можете создать классы Собака и Кошка, которые наследуют свойства и методы от класса Животное, но могут также добавлять свои уникальные характеристики.

```php
class Animal {
    public function speak() {
        return "Животное издает звук";
    }
}

class Dog extends Animal {
    public function speak() {
        return "Гав!";
    }
}

class Cat extends Animal {
    public function speak() {
        return "Мяу!";
    }
}
```

4. Полиморфизм

Полиморфизм позволяет использовать один интерфейс для работы с разными типами объектов. Это означает, что один и тот же метод может вести себя по-разному в зависимости от объекта.

Пример: В примере с животными метод speak() может быть переопределен в каждом подклассе (Собака, Кошка), чтобы возвращать разные звуки.

```php
function animalSound(Animal $animal) {
    echo $animal->speak();
}

$dog = new Dog();
$cat = new Cat();

animalSound($dog); // Вывод: Гав!
animalSound($cat); // Вывод: Мяу!
```

5. Абстракция

Абстракция позволяет выделить важные характеристики объекта и скрыть ненужные детали. В PHP это достигается с помощью абстрактных классов и интерфейсов.

Пример: Вы можете создать абстрактный класс Форма с абстрактным методом draw(), который должны реализовать все подклассы, такие как Круг, Квадрат и т.д.

```php
abstract class Shape {
    abstract public function draw();
}

class Circle extends Shape {
    public function draw() {
        echo "Рисуем круг";
    }
}

class Square extends Shape {
    public function draw() {
        echo "Рисуем квадрат";
    }
}
```

## Видимые отличия:

Наследование класса Животное

1. Классическое наследование в PHP

В PHP мы создадим базовый класс Animal и два производных класса Dog и Cat, которые наследуют от Animal.

```php
<?php
// Базовый класс
class Animal {
    public function speak() {
        return "Животное издает звук";
    }
}

// Класс Dog наследует от Animal
class Dog extends Animal {
    public function speak() {
        return "Гав!";
    }
}

// Класс Cat наследует от Animal
class Cat extends Animal {
    public function speak() {
        return "Мяу!";
    }
}

// Использование классов
$dog = new Dog();
$cat = new Cat();

echo $dog->speak(); // Вывод: Гав!
echo $cat->speak(); // Вывод: Мяу!
?>
```

2. Прототипное наследование в JavaScript

В JavaScript мы можем создать объект Animal и использовать его как прототип для объектов Dog и Cat.

```javascript
// Базовый объект
const Animal = {
    speak: function() {
        return "Животное издает звук";
    }
};

// Создаем объект Dog, используя прототип Animal
const Dog = Object.create(Animal);
Dog.speak = function() {
    return "Гав!";
};

// Создаем объект Cat, используя прототип Animal
const Cat = Object.create(Animal);
Cat.speak = function() {
    return "Мяу!";
};

// Использование объектов
console.log(Dog.speak()); // Вывод: Гав!
console.log(Cat.speak()); // Вывод: Мяу!
```

Сравнение

1. Определение:

   • В PHP мы определяем классы с помощью ключевого слова class, а затем создаем экземпляры этих классов с помощью new.

   • В JavaScript мы создаем объекты и используем Object.create() для установки прототипа.

2. Наследование:

   • В PHP класс Dog наследует от класса Animal, что позволяет ему использовать методы родительского класса.

   • В JavaScript объект Dog наследует от объекта Animal, что позволяет ему использовать методы родительского объекта.

3. Методы:

   • В PHP методы определяются внутри класса и могут быть переопределены в подклассах.

   • В JavaScript методы могут быть добавлены к объектам после их создания, и мы можем переопределить их непосредственно на объекте.


### Классы и прототипы:

JavaScript: Определение класса и прототипа

В JavaScript мы можем использовать ключевое слово class, чтобы явно объявить класс, или использовать функции-конструкторы и прототипы для создания объектов. Вот два примера:

Пример 1: Класс

```javascript
class Animal {
    speak() {
        return "Животное издает звук";
    }
}

const dog = new Animal();
console.log(dog instanceof Animal); // true
console.log(dog.speak()); // "Животное издает звук"
```

Пример 2: Прототип

```javascript
function Animal() {}

Animal.prototype.speak = function() {
    return "Животное издает звук";
};

const dog = new Animal();
console.log(dog instanceof Animal); // true
console.log(dog.speak()); // "Животное издает звук"
```

Как интерпретатор определяет, что это класс или прототип?

1. Классы:

   • Когда интерпретатор видит конструкцию с ключевым словом class, он понимает, что это объявление класса. 

   • При создании экземпляра класса с помощью new, он создает объект, который имеет внутреннюю ссылку на прототип класса.

2. Прототипы:

   • Когда интерпретатор видит функцию (например, function Animal() {}), он понимает, что это функция-конструктор.

   • Методы добавляются к Animal.prototype, и при создании экземпляра с помощью new он также создает объект с ссылкой на Animal.prototype.

PHP: Определение класса

В PHP классы определяются с использованием ключевого слова class. Вот пример:

```php
class Animal {
    public function speak() {
        return "Животное издает звук";
    }
}

$dog = new Animal();
echo $dog instanceof Animal ? 'true' : 'false'; // true
echo $dog->speak(); // "Животное издает звук"
```

Как интерпретатор определяет класс в PHP?

• PHP использует ключевое слово class для определения класса. Когда вы создаете экземпляр класса с помощью new, PHP создает объект этого класса.

• Также, как и в JavaScript, оператор instanceof может быть использован для проверки принадлежности объекта к классу.

## Как работать с классами в JavaScript?

1. class

Определение: Используется для объявления нового класса.

```javascript
class Animal {
    constructor(name) {
        this.name = name;
    }
}
```

2. constructor

Определение: Специальный метод, который вызывается при создании нового экземпляра класса. Он используется для инициализации свойств объекта.

```javascript
class Animal {
    constructor(name) {
        this.name = name;
    }
}

const dog = new Animal('Buddy');
console.log(dog.name); // "Buddy"
```

3. extends

Определение: Используется для создания класса, который наследует свойства и методы другого класса (родительского класса).

```javascript
class Animal {
    constructor(name) {
        this.name = name;
    }
}

class Dog extends Animal {
    bark() {
        return ${this.name} говорит: Гав!;
    }
}

const dog = new Dog('Buddy');
console.log(dog.bark()); // "Buddy говорит: Гав!"
```

4. super

Определение: Используется для вызова конструктора родительского класса или методов родительского класса внутри дочернего класса.

```javascript
class Animal {
    constructor(name) {
        this.name = name;
    }
}

class Dog extends Animal {
    constructor(name, breed) {
        super(name); // Вызов конструктора родительского класса
        this.breed = breed;
    }

    bark() {
        return ${this.name} говорит: Гав!;
    }
}

const dog = new Dog('Buddy', 'Лабрадор');
console.log(dog.bark()); // "Buddy говорит: Гав!"
console.log(dog.breed); // "Лабрадор"
```

5. static

Определение: Используется для определения статических методов или свойств, которые принадлежат самому классу, а не его экземплярам.
```javascript
class Animal {
    static numberOfLegs = 4; // Статическое свойство

    static getLegs() { // Статический метод
        return this.numberOfLegs;
    }
}

console.log(Animal.numberOfLegs); // 4
console.log(Animal.getLegs()); // 4
```

6. get и set

Определение: Используются для определения геттеров и сеттеров, которые позволяют управлять доступом к свойствам объекта.

```javascript
class Animal {
    constructor(name) {
        this._name = name; // Приватное свойство с подчеркиванием
    }

    get name() { // Геттер
        return this._name;
    }

    set name(newName) { // Сеттер
        this._name = newName;
    }
}

const dog = new Animal('Buddy');
console.log(dog.name); // "Buddy"
dog.name = 'Max';
console.log(dog.name); // "Max"
```

7. this

Определение: Ссылается на текущий экземпляр класса. Используется для доступа к свойствам и методам объекта.

```javascript
class Animal {
    constructor(name) {
        this.name = name;
    }

    speak() {
        return ${this.name} издает звук;
    }
}

const dog = new Animal('Buddy');
console.log(dog.speak()); // "Buddy издает звук"
```

